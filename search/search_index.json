{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPGRARS","text":""},{"location":"#fast-pretty-good-risc-v-assembly-rendering-system","title":"Fast Pretty Good RISC-V Assembly Rendering System","text":""},{"location":"configuration/","title":"Configuration","text":"<p>There are two ways to configure FPGRARS: by passing command-line arguments or by using an <code>fpgrars.toml</code> file.</p>"},{"location":"configuration/#command-line-arguments","title":"Command-line arguments","text":"<p>When you run fpgrars --help, you will see the available arguments for your specific version of FPGRARS, like it's shown below. Do note that the version on this website might not always be up to date. </p> <pre><code>&gt; fpgrars --help\nFast Pretty Good RISC-V Assembly Rendering System\n\nUsage: fpgrars [OPTIONS] [FILE]\n\nArguments:\n  [FILE]  The RISC-V file to execute\n\nOptions:\n      --no-video            Hides the bitmap display\n  -w, --width &lt;WIDTH&gt;       The width of the bitmap display. Defaults to 320px\n  -h, --height &lt;HEIGHT&gt;     The height of the bitmap display. Defaults to 240px\n  -s, --scale &lt;SCALE&gt;       Each pixel is scaled by this factor. Defaults to 2 (each pixel becomes a 2x2 square)\n  -p, --port &lt;PORT&gt;         The MIDI port to use for audio\n      --print-instructions  Prints the instructions in the FPGRARS format\n      --print-state         Prints the final state of the program after execution\n  -h, --help                Print help\n  -V, --version             Print version\n</code></pre> <p>For example, if you want to run FPGRARS without the bitmap display and print the state of the registers when the program exits, you can use the command </p> <pre><code>fpgrars --no-video --print-state file.s\n</code></pre> <p>As another example, if you want the bitmap display to be 1280 x 720 and display each pixel as a 1x1 square (an actual pixel), you should run</p> <pre><code>fpgrars -w 1280 -h 720 -s 1\n</code></pre> <p>In this case, you probably want to run FPGRARS with this configuration every time your project is executed. The next section outlines a way to do this.</p>"},{"location":"configuration/#configuration-file-fpgrarstoml","title":"Configuration file (fpgrars.toml)","text":"<p>If FPGRARS detects an <code>fpgrars.toml</code> in the current working directory, it will use the configuration defined there by default. For example, suppose the working directory is structured like this:</p> <pre><code>|- fpgrars.toml\n|- src\n|  |- main.s\n</code></pre> <p>and <code>fpgrars.toml</code> contains the following:</p> <pre><code>width = 1280\nheight = 720\nscale = 1\n</code></pre> <p>Then, running <code>fpgrars src/main.s</code> is the same as <code>fpgrars --width 1280 --height 720 --scale 1</code>.</p> <p>You could also specify a default file to run, for example:</p> <pre><code># fpgrars.toml\nfile = \"src/main.s\"\n</code></pre> <p>Then, running <code>fpgrars</code> is the same as <code>fpgrars src/main.s</code>.</p> <p>It's worth noting that you can still pass command-line arguments in addition to using <code>fpgrars.toml</code>, in which case any options you pass by command-line will take priority over the ones defined in the config file.</p>"},{"location":"ecalls/","title":"Supported Ecalls","text":"Description a7 Input Output Print integer 1 a0 = integer to print Print float 2 fa0 = float to print Print string 4 a0 = address of the string Read int 5 a0 = the read integer Read float 6 fa0 = the read float Sbrk 9 a0 = bytes to allocate (&gt;= 0) a0 = address of the allocated chunk Exit 10 a0 = exit code Exit 93 a0 = exit code Stop execution 110 Print char 11 a0 = the char Time 30 a0 = low bits of milliseconds since unix epoch, a1 = high bits Midi out 31 a0 = pitch (note), a1 = duration in ms, a2 = instrument (in range 0-127), a3 = volume (also 0-127) Async sound Sleep ms 32 a0 = number of milliseconds to sleep Midi out sync 33 a0 = pitch (note), a1 = duration in ms, a2 = instrument (in range 0-127), a3 = volume (also 0-127) Synchronous sound Print hex integer 34 a0 = integer to print Print unsigned integer 36 a0 = unsigned integer to print Rand seed 40 does nothing for now Rand int 41 a0 = random integer Rand int range 42 a0 is discarded, a1 = upper bound a0 = random integer in [0, a1) Rand float 43 fa0 = random float in [0, 1) Clear screen 48 or 148 a0 = color, a1 = frame Open file 1024 a0 = address of the null-terminated string for the path, a1 = 0 (read mode), 1 (write mode) or 9 (append mode) a0 = the file descriptor or -1 if error Close file 57 a0 = a file descriptor Seek 62 a0 = a file descriptor, a1 = the offset to seek, a2 = 0 (seek from the start of the file), 1 (from the current position) or 2 (from the end) a0 = the selected position from the start of the file Read 63 a0 = a file descriptor, a1 = address of the buffer, a2 = maximum length to read a0 = number of bytes read or -1 if error Write 64 a0 = a file descriptor, a1 = address of the buffer, a2 = length to write a0 = number of bytes written of -1 if error"},{"location":"midi/","title":"MIDI","text":"<p>If you're running Windows, MIDI ecalls should work out of the box! On Linux, however, you need to install a software synthesizer and a soundfont. I recommend following the Timidity++ guide until the section that explains how to run the daemon.</p> <p>Note that <code>systemctl start timidity</code> may fail with the error \"Failed to start timidity.service: Unit timidity.service not found.\", in which case you may try <code>systemctl --user start timidity</code> instead, or run <code>timidity -iA</code> as a last resort.</p> <p>FPGRARS takes a <code>--port</code> argument that specifies the MIDI port to use. You can find the port number by running <code>aplaymidi -l</code> and finding a TiMidity port. Although in my  experience some of them might not work :)</p>"}]}