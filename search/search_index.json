{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPGRARS","text":""},{"location":"#fast-pretty-good-risc-v-assembly-rendering-system","title":"Fast Pretty Good RISC-V Assembly Rendering System","text":"<p>FPGRARS is a RISC-V assembly simulator with a graphics display window and keyboard input, similar to RARS, but 200 times faster. If you want to run RISC-V assembly programs easily, learn assembly language, or even build a game, FPGRARS is a great option! (and if it isn't for you please open an issue) :) </p>"},{"location":"#running-fpgrars","title":"Running FPGRARS","text":"<p>First, head over to the latest release and download the appropriate executable. Then, you can run a RISC-V assembly file either by running <code>./fpgrars your_riscv_file.s</code> in a terminal or by dragging the <code>.s</code> onto the executable. If you're on Linux, you might need to <code>chmod +x fpgrars-x86_64-unknown-linux-gnu</code> for FPGRARS to work.</p> <p>If you have the Rust toolchain installed, you can also download FPGRARS by running <code>cargo install fpgrars</code>.</p> <p>You may also want to check out Getting Started for a more detailed guide.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>There are two ways to configure FPGRARS: by passing command-line arguments or by using an <code>fpgrars.toml</code> file.</p>"},{"location":"configuration/#command-line-arguments","title":"Command-line arguments","text":"<p>When you run fpgrars --help, you will see the available arguments for your specific version of FPGRARS, like it's shown below. Do note that the version on this website might not always be up to date. </p> <pre><code>&gt; fpgrars --help\nFast Pretty Good RISC-V Assembly Rendering System\n\nUsage: fpgrars [OPTIONS] [FILE]\n\nArguments:\n  [FILE]  The RISC-V file to execute\n\nOptions:\n      --no-video            Hides the bitmap display\n  -w, --width &lt;WIDTH&gt;       The width of the bitmap display. Defaults to 320px\n  -h, --height &lt;HEIGHT&gt;     The height of the bitmap display. Defaults to 240px\n  -s, --scale &lt;SCALE&gt;       Each pixel is scaled by this factor. Defaults to 2 (each pixel becomes a 2x2 square)\n  -p, --port &lt;PORT&gt;         The MIDI port to use for audio\n      --print-instructions  Prints the instructions in the FPGRARS format\n      --print-state         Prints the final state of the program after execution\n  -h, --help                Print help\n  -V, --version             Print version\n</code></pre> <p>For example, if you want to run FPGRARS without the bitmap display and print the state of the registers when the program exits, you can use the command </p> <pre><code>fpgrars --no-video --print-state file.s\n</code></pre> <p>As another example, if you want the bitmap display to be 1280 x 720 and display each pixel as a 1x1 square (an actual pixel), you should run</p> <pre><code>fpgrars -w 1280 -h 720 -s 1\n</code></pre> <p>In this case, you probably want to run FPGRARS with this configuration every time your project is executed. The next section outlines a way to do this.</p>"},{"location":"configuration/#configuration-file-fpgrarstoml","title":"Configuration file (fpgrars.toml)","text":"<p>If FPGRARS detects an <code>fpgrars.toml</code> in the current working directory, it will use the configuration defined there by default. For example, suppose the working directory is structured like this:</p> <pre><code>|- fpgrars.toml\n|- src\n|  |- main.s\n</code></pre> <p>and <code>fpgrars.toml</code> contains the following:</p> fpgrars.toml<pre><code>width = 1280\nheight = 720\nscale = 1\n</code></pre> <p>Then, running <code>fpgrars src/main.s</code> is the same as <code>fpgrars --width 1280 --height 720 --scale 1</code>.</p> <p>You could also specify a default file to run, for example:</p> fpgrars.toml<pre><code>file = \"src/main.s\"\n</code></pre> <p>Then, running <code>fpgrars</code> is the same as <code>fpgrars src/main.s</code>.</p> <p>It's worth noting that you can still pass command-line arguments in addition to using <code>fpgrars.toml</code>, in which case any options you pass by command-line will take priority over the ones defined in the config file.</p>"},{"location":"ecalls/","title":"Supported Ecalls","text":"Description a7 Input Output Print integer 1 a0 = integer to print Print float 2 fa0 = float to print Print string 4 a0 = address of the string Read int 5 a0 = the read integer Read float 6 fa0 = the read float Sbrk 9 a0 = bytes to allocate (&gt;= 0) a0 = address of the allocated chunk Exit 10 a0 = exit code Exit 93 a0 = exit code Stop execution 110 Print char 11 a0 = the char Time 30 a0 = low bits of milliseconds since unix epoch, a1 = high bits Midi out 31 a0 = pitch (note), a1 = duration in ms, a2 = instrument (in range 0-127), a3 = volume (also 0-127) Async sound Sleep ms 32 a0 = number of milliseconds to sleep Midi out sync 33 a0 = pitch (note), a1 = duration in ms, a2 = instrument (in range 0-127), a3 = volume (also 0-127) Synchronous sound Print hex integer 34 a0 = integer to print Print unsigned integer 36 a0 = unsigned integer to print Rand seed 40 does nothing for now Rand int 41 a0 = random integer Rand int range 42 a0 is discarded, a1 = upper bound a0 = random integer in [0, a1) Rand float 43 fa0 = random float in [0, 1) Clear screen 48 or 148 a0 = color, a1 = frame Open file 1024 a0 = address of the null-terminated string for the path, a1 = 0 (read mode), 1 (write mode) or 9 (append mode) a0 = the file descriptor or -1 if error Close file 57 a0 = a file descriptor Seek 62 a0 = a file descriptor, a1 = the offset to seek, a2 = 0 (seek from the start of the file), 1 (from the current position) or 2 (from the end) a0 = the selected position from the start of the file Read 63 a0 = a file descriptor, a1 = address of the buffer, a2 = maximum length to read a0 = number of bytes read or -1 if error Write 64 a0 = a file descriptor, a1 = address of the buffer, a2 = length to write a0 = number of bytes written of -1 if error"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#with-fpgrars-and-risc-v-assembly","title":"With FPGRARS and RISC-V assembly","text":"<p>In this guide, we'll go over the basics of running RISC-V assembly programs with FPGRARS!</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>If you haven't yet downloaded FPGRARS, head over to the latest release and download the appropriate executable. The easiest way to \"install\" it is by putting it in the same folder as our assembly file:</p> <pre><code>my-wonderful-riscv-project\n|- fpgrars-executable\n|- riscv.s\n</code></pre> <p>If you later want to use FPGRARS for multiple projects, it's best to put the executable in a folder that's in your <code>PATH</code> environment variable (could be <code>~/.local/bin</code> for Unix, idk where for Windows sorry /shrug).</p> <p>If you have the Rust toolchain installed, you can also download FPGRARS by running <code>cargo install fpgrars</code>.</p>"},{"location":"getting-started/#hello-world","title":"Hello World!","text":"<p>Create a <code>riscv.s</code> file and put the following content in it:</p> <pre><code>.data\n# Define the label \"hello\" to as the address to the very start\n# of the \"Hello World!\\n\" string \nhello: .string \"Hello World!\\n\"\n\n.text\n    li a7, 4     # Load 4 (the ecall for \"print string\") into the a7 register\n    la a0, hello # Load the address of the label 'hello' into a0\n    ecall        # Perform an environment call\n\n    li a7, 11    # Load 11 (\"print character\" ecall) into a7\n    li a0, '\\n'  # Load '\\n' into a0\n    ecall        # Perform an environment call\n\n    li a7, 10    # \"exit\" ecall\n    li a0, 0     # exit with code 0 \n    ecall\n</code></pre> <p>You can now run the program with the command <code>./fpgrars riscv.s</code> and you should see a \"Hello World\" appear on your terminal!</p> <p>Note that <code>./fpgrars</code> should have the full name of the executable file. On Windows, it's probably something like <code>./fpgrars-x86_64-pc-windows-msvc--original.exe</code>, on Linux, <code>./fpgrars-x86_64-unknown-linux-gnu--original</code>. Of course, you can rename it to whatever you want, like just <code>fpgrars</code>.</p>"},{"location":"getting-started/#using-the-bitmap-display","title":"Using the Bitmap Display","text":"<p>This section is WIP :) </p> <p>While I'm working on that, check out the samples folder! There are many examples there that may help you. I guess keyboard_and_display_demo.s is the easiest to follow, but polygon.s is definitely the coolest.</p>"},{"location":"midi/","title":"MIDI","text":"<p>If you're running Windows, MIDI ecalls should work out of the box! On Linux, however, you need to install a software synthesizer and a soundfont. I recommend following the Timidity++ guide until the section that explains how to run the daemon.</p> <p>Note that <code>systemctl start timidity</code> may fail with the error \"Failed to start timidity.service: Unit timidity.service not found.\", in which case you may try <code>systemctl --user start timidity</code> instead, or run <code>timidity -iA</code> as a last resort.</p> <p>FPGRARS takes a <code>--port</code> argument that specifies the MIDI port to use. You can find the port number by running <code>aplaymidi -l</code> and finding a TiMidity port. Although in my  experience some of them might not work :)</p>"}]}